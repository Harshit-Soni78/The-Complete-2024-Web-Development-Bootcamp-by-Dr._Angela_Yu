# Level 3 - How to Salt Passwords for Improved Encryption

## Introduction to Salting Passwords

Now that we have examined some vulnerabilities associated with hashed passwords, it is time to level up and learn about a method to prevent dictionary attacks and hash table cracking. This method is called salting.

### What is Salting?

We already know that hashing involves taking a password and running it through a hash function to produce a hash stored in our database. However, passwords generated by humans tend to be insecure; they are often short and consist of dictionary words, making them easy to look up and create hash tables for.

Salting takes hashing a step further. In addition to the password, a random set of characters called a salt is generated. This salt is combined with the user's password and then passed through the hash function. The resulting hash is created from both the password and the unique salt.

This means that no matter how simple the user's password is, adding the salt increases its complexity and length, thereby making the user database much more secure.

### Example of Salting

Consider the previous problem where three users had the same password, which was evident because they all had the same hash. If we had generated a random salt for each user and combined it with their password before hashing, their hashes would be different in the database.

For example, if Emily's password is "qwerty" and we generate a random salt, we append the salt to her password and then hash the combined string. This hash will differ from Tony's or Angela's hashes because their salts are different.

The salt is stored in the database alongside the hash, and the user does not need to remember it. When the user logs in, their entered password is combined with the stored salt, and if the resulting hash matches the stored hash, the password is correct.

### Limitations of MD5 and the Need for Better Hashing Algorithms

Previously, we noted that it is possible to generate about 20 billion MD5 hashes per second. Even with salting, it is still feasible to generate hash tables with all salt combinations relatively quickly using modern GPUs.

To increase security, we can use a different hashing algorithm that is intentionally slow. This is where Bcrypt comes in.

### Bcrypt: Industry Standard for Password Hashing

Bcrypt is an industry-standard hashing algorithm used to keep users' passwords safe. While GPUs can compute 20 billion MD5 hashes per second, they can only compute about 17,000 Bcrypt hashes per second. This dramatic difference makes it much harder for hackers to generate precompiled hash tables.

For example, cracking a password hashed with MD5 might take three seconds, but with Bcrypt, it could take about eight months, which is generally not worth a hacker's effort.

### Salt Rounds in Bcrypt

Bcrypt introduces the concept of salt rounds, which refers to how many times the password is salted and hashed. The more rounds, the "saltier" and more secure the password becomes against hackers.

For instance, if the original password is "qwerty" and a random salt is generated, passing this through Bcrypt once produces a hash (one round). If we take that hash, add the same salt, and hash it again, we get a different hash (two rounds). The number of times this process is repeated is the number of salt rounds.

This approach is clever because as computers get faster (following Moore's Law), the number of salt rounds can be increased to maintain security without changing the hashing algorithm or code, just by adjusting a single number.

### Storing User Credentials with Salting and Hashing

In the user database, each user's username, randomly generated salt, and the hash after the specified number of salting rounds are stored. When a user logs in, their entered password is combined with the stored salt and hashed through the same number of rounds. The resulting hash is compared to the stored hash to verify the password.

## Implementing Bcrypt in a Node.js Project

We will now implement Bcrypt and salting rounds into our website's authentication system. The package we will use is called "bcrypt," available on NPM.

First, download and extract the project files for this lesson. Open the project in VS Code. Inside the `index.js` file, you will find the code from the previous lesson, which currently does not include hashing.

In the `package.json` file, you will notice the new dependency `bcrypt`. Bcrypt uses the Blowfish algorithm, a modern and secure method to ensure that current computational skills cannot decode passwords in a reasonable time.

To set up, navigate to the project directory and run `npm install` to add all node modules.

### Importing Bcrypt and Setting Salt Rounds

Import the bcrypt module:

```js
import bcrypt from "bcrypt";
```

Define the number of salt rounds:

```js
const saltRounds = 10;
```

The number of salt rounds depends on the desired security level. More rounds increase computation time and security.

### Hashing Passwords During Registration

In the register POST route, before saving the user's email and password to the database, hash the password using bcrypt's `hash()` method. This method takes the password, the number of salt rounds, and a callback function that returns an error or the hashed string.

```js
bcrypt.hash(password, saltRounds, async function (err, hash) {
  if (err) {
    console.log(err);
  } else {
    // Store hash in your password DB.
    const newUser = new User({
      email: email,
      password: hash,
    });
    await newUser.save();
    res.render("secrets");
  }
});
```

Note that the callback is asynchronous because we wait for the database save operation to complete before rendering the "secrets" page.

### Testing Registration

Start the server and navigate to the home page. Register a new user with a password such as "123456". In the database, you will see the new user with a hashed password instead of the plain text password.

### Comparing Passwords During Login

When a user tries to log in, you cannot simply hash the entered password and compare it to the stored hash because Bcrypt's salting rounds produce different hashes each time.

Instead, use Bcrypt's `compare()` method, which compares the entered password with the stored hash and returns whether they match.

```js
bcrypt.compare(loginPassword, storedHashedPassword, function (err, result) {
  if (err) {
    console.log(err);
  } else if (result === true) {
    res.render("secrets");
  } else {
    res.send("Incorrect password.");
  }
});
```

The order of arguments in `compare()` is important: the first is the plain text password entered by the user, and the second is the stored hashed password.

