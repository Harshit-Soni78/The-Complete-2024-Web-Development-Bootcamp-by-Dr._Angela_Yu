# Motoko Functions and the Candid User Interface

## Introduction to Functions in Motoko

In the previous lesson, we explored how to use variables and constants in the Motoko programming language. We also learned how to import libraries from the Motoko-based library and use them for tasks such as printing to the console.

In this lesson, we will delve deeper and add more functionality to our actor, specifically the DBank canister. One essential feature for a money market application is allowing users to deposit their cryptocurrencies or money into the application. To achieve this, we need to create a function.

## Creating a Function in Motoko

In Motoko, functions are created with the `func` keyword, similar to the Swift programming language. The next step is to give the function a name, such as `topUp`, and then open a set of curly brackets to define what happens when the function is triggered.

```mo
    func topUp() {
      currentValue += 1;
      Debug.print(debug_show(currentValue));
    }
```

Here, each time the `topUp()` function is called, it increases `currentValue` by 1. The previous debug print statement should be commented out to avoid confusion. At the end of the function, we print the new value of this variable using Motoko's `Debug.print` and `debug_show`.

## Calling the Function and Syntax Requirements

After defining the function, it can be called just below its creation. It is important to remember that every function in Motoko must be closed with a semicolon. If omitted, errors will occur.

```mo
    topUp();
```

When the function is called and the code is deployed using `dfx deploy`, the output will show that `currentValue` has been incremented by 1 and printed. This demonstrates how to call a function inside our DBank canister.

## Private vs Public Functions

The function created above is a private function, meaning it is only accessible within the actor's curly braces. However, as seen in the Hello World application, functions within canisters can be called from the outside.

To call a function from the command line, follow the structure provided in the documentation. After deploying, use the following command format:

```bash
    dfx canister call dbank topUp
```

However, if the function is private, attempting to call it from the command line will result in an error stating that the canister has no update method called `topUp`. This is because the function is not visible outside the actor.

## Making a Function Public

To allow external calls to the function, add the `public` modifier keyword. This exposes the function to the public, enabling it to be called from outside the canister, such as from the command line.

```mo
    public func topUp() {
      currentValue += 1;
      Debug.print(debug_show(currentValue));
    }
```

After saving the file and redeploying with `dfx deploy`, the command line call to `topUp` will now execute successfully, and the incremented value will be printed.

## Introducing the Candid UI

Typing out command line calls repeatedly can be tedious. The Candid UI provides a simple user interface to trigger canister functions without manual command line input. Candid is an interface description language that allows interactive documentation and UI for canisters, similar to interactive API documentation like GitLab's 'try it out' feature.

Instead of using the dfx command line, Candid UI allows specifying input arguments, generating random inputs, and displaying return values from canister methods. This provides a graphical interface for interacting with canisters.

## Accessing the Candid UI

To use the Candid UI, first obtain the canister ID for the interface. This can be done with the following command:

```bash
    dfx canister id __Candid_UI
```

After obtaining the Candid UI canister ID, navigate to the localhost server and append `?canisterId=` followed by the ID to the URL. The UI will prompt for another canister ID, which is the ID of your program's canister. Retrieve it with:

```bash
    dfx canister id dbank
```

Paste this ID into the Candid UI field and click the GO button. The Candid UI is automatically generated by reading your canister code, requiring no front-end work. You will see the `topUp` function available for interaction.

Now, instead of typing `dfx canister call`, you can simply tap the call button in the UI. The output confirms the function executed, and `currentValue` is incremented by 1 each time you call it. This simplifies interaction with canisters during testing and development.

## Adding Inputs to Functions

Typically, when topping up, you want to specify an amount rather than incrementing by 1 each time. To add an input to the function, provide a name and data type in the function's parameters. For example, use `amount` as a parameter of type `Nat` (natural number).

```mo
    public func topUp(amount: Nat) {
      currentValue += amount;
      Debug.print(debug_show(currentValue));
    }
```

After saving and redeploying, refreshing the Candid UI will show a field for entering a natural number. Entering a value such as 12 and calling the function will increase the total amount by 12.

## Orthogonal Persistence and Variable Reset

After deploying new code, you may notice that variables reset to their initial values. This is due to orthogonal persistence, which will be discussed in more detail in a future lesson. For now, remember that running `dfx deploy` resets all variables.
